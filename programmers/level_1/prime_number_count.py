"""
1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
(1은 소수가 아닙니다.)

제한 조건
n은 2이상 1,000,000이하의 자연수입니다.

입출력 예
n	result
10	4
5	3

입출력 예 설명
입출력 예 #1
1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환

입출력 예 #2
1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환
"""


def runtime(func):
    import time

    def print_time(*args):
        start_time = time.time()
        result = func(*args)

        print(func.__name__ + " (1 ~ " + "{:,}".format(*args) + ")")
        print(time.time() - start_time)

        return result
    return print_time


@runtime
def bingl2_solution(n):
    # 에라토스테네스의 체를 활용하였다.
    # 정답 리스트를 만듬
    answer_array = list(range(2, n + 1))
    # 거를 숫자들의 범위를 지정함. (n이 합성수라면 적어도 하나는 제곱근 이하이기 때문)
    eratos_range = list(range(2, int(n ** 0.5 + 1)))

    # 채의 도는 수
    for er_num in eratos_range:
        # 정답을 제거해 나갈 수 (2의 배수로 시작)
        for check_num in answer_array:
            # 본인은 나누어 떨어지기 때문에, 본인 이외 체크
            if check_num != er_num:
                # 그 이외의 나누어 떨어질 경우 소수가 아님.
                if check_num % er_num == 0:
                    # 만약 삭제할 숫자가 eraots_range 에 존재할 경우 제거
                    if check_num in eratos_range:
                        eratos_range.remove(check_num)
                    # 정답 리스트에서 체크한 숫자 제거
                    answer_array.remove(check_num)

        # 일단 지속적으로 최적화를 시켜볼 생각이다.
        # 중간에 존재하는 본인 이외의 숫자 체크 등의 부분 ..

    # 정답 리스트 길이 반환
    return len(answer_array)


# 출처는 위키피디아에서 가져왔다. 정말 체가 무엇인지 보여주는 코드였다. 리스트 하나 하나의 비교 연산이 아닌, 자리수로 체를 쳐버리는데 보고 감격을 먹었다.
# 소수 구하는 함수야 정말 빠르게 만들었는데 10만에서, 100만으로 가면 갈수록 속도가 느려져서 답이 안보였는데 정말 명쾌한 답을 보았다.
@runtime
def best_solution(n):
    # n 의 값을 지속적으로 사용하는데, 배열을 만들때 * n 을 하면서, 0의 자리를 0으로 사용하였다. 그래서 + 1 을 해줬다.
    # 예를 들어 5를 넣어 돌린다고 했을 경우 [True, True, True, True, True], [0, 1, 2, 3, 4] 를 하는데 밑에 줄을 보면 0과 1을 None 처리를 한다.
    # 그래서 임의로 1칸을 더 늘려 갯수를 맞췄다. [None(0), None(0), True(2), True(3), True(4), True(5)]
    n += 1
    # 여기서 감탄을 했다. 생각하지도 못했다. 숫자 비교 연산이 아닌, 자리에서 비교 연산으로 처리를 하니 일단 메모리 비용을 박살내고 간다 ..
    primes = [True] * n
    # 0 과 1은 None 처리를 한다.
    primes[0], primes[1] = [None] * 2

    # 제너레이터 이너머레이트의 index 를 사용하여 굳이 list 에 메모리 낭비를 하지 않았다.
    for ind, val in enumerate(primes):
        # n ** 0.5 + 1 의 숫자보다 index 가 큰데도 남아있다면, 이 숫자는 소수임이 확정이다. n이 합성수라면 적어도 하나는 제곱근 이하이기 때문이다.
        # n 이 1000 일경우 32가 나오는데, 32 * 32 = 1024 가 넘어간다. 그래서 밑에서부터 소수 이외의 수를 제거해 나가는데 거기서 걸리지 않았고, 제곱근 이상 이기 때문에 소수 확정!
        if val is True and ind > n ** 0.5 + 1:
            pass
        elif val is True:
            # 소수가 아닌 수를 거르는 로직이다. 에라토스테네스의 체는 본인이외의 배수에 해당하는 수는 합성수 이기 때문에 제외를 시키는 방법이다.
            # 숫자 비교 연산이 아닌, 현재 배열의 자리수로 index 가 2일 경우 (본인 이외이기 때문) pimes[4::2] 4부터 2칸씩 끝까지의 리시트를 뽑아낸다.
            # 정말 여기서 깜짝 놀랐다. 그러면 정말 체로 걸러내듯이 2의 배수를 잡아낸다.
            # 그리고 뒤에는 1001 - 1 => 1000 // 2 => 500 - 1 = 499 가 나오는데 그만큼 False 처리를 한다는 의미다.
            # 간단하게 1000에서 2의 배수는 500개다. 1000 / 2 = 500 하지만 본인 2는 소수이기 때문에  빠져야 하기 때문에 계산으로 499개가 나온다.
            # 그리고 앞에서 계산한 그 자리수 들에 False 를 대입 시킨다. 그리고 이 방법을 반복한다.
            primes[ind * 2::ind] = [False] * (((n - 1) // ind) - 1)

            # 위처럼 처리하는 방식과 직접 한개씩 대입해주는 것에 차이점을 느끼고 싶어 for 문을 같은 단위로 돌아가며 그 부분에 하나씩 채워주도록 작성해보았다.
            # 비교 결과 대략 1.5배 정도 속도의 차이가 난다. 물론 위의 코드가 더 빨랐다.
            # 좀더 확인을 해봐야겠지만 위의 코드는 한번에 처리를 진행을 하지 않을까 추측을 했다.
            # for a in range(ind*2, n, ind):
            #     primes[a] = False

    # 그리고 primes 의 True(소수) 인 값들을 카운트 하여 리턴해준다.
    return primes.count(True)


assert bingl2_solution(10000) == 1229
assert best_solution(1000000) == 78498, best_solution(1000000)


"""
후기 

레벨 1 단계에 있는 것을 보고 정말 가벼운 마음으로 문제를 풀었다. 
소수의 개수를 구하는 거야 정말 빠르게 풀었는데, 1천, 1만, 10만, 100만이 되어 가니 머리가 터지기 시작했다.

도대체 어떻게 줄여야할까 많은 고민을 했다.

에라토스테네스의 체를 찾아서 비슷하게 구현하며 줄여가고, 목표 숫자와 제곱근의 사이를 생각해서 추가하고 .. 
시간초가 줄어들 수록 기분은 정말 좋았지만, 10만의 벽을 뚫지 못했다. 

그러다 위키피디아에서 에라토스테네스의 체를 보다가 밑에 범위 숫자 소수 더하기 코드를 발견하였고, 그거를 문제에 맞게 수정을 하였다.
코드를 읽으면서 정말 감탄을 많이했다. 이렇게 메모리를 아끼는구나, 정말 빠른게 뭔지 최적화가 뭔지 배우는 좋은 경험이 된것 같다.

일단 빙글이 솔루션은 그래도 내가 만들어낸 소중한 알고리즘이기에 남겨뒀다.
앞으로 계속 공부하며 빙글이 솔루션을 최적화 시켜야겠다. 메모리 사용부터, 처리 속도 등에 대한 조건등 까지 ..

(근데 이거 레벨 1짜리는 아닌것 같다 ...)
"""